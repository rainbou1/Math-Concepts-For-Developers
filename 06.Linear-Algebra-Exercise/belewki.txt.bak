Ray tracer
Дървото на Huffman е само по себе си лесна задача. Но.
Къде се ползва?
Какви алгоритми?
Какви са алтернативите?
Как мога да тествам с моята имплементация с друга имплементация?
Как мога да тествам различни алгоритми за компресия?
Как се прави компресия на текст и изображение?
Как си взаимодействат компресията и криптирането?


От упражнението:
В едно пространство можем произволно да си изберем базис. Това е начин да разберем кое накъде.
Базис е генерализация на координатна система.
Базис и друг базис са напълно еквивалентни.
Избирането на базиса зависи колко ще ни е удобно.
Друга гледна точка е трансформацията.
При базисите характеристиките на векторите остават същите. 
При трансформацията векторите се променят, а пространството остава същото.

Използваме numpy защото python e много бавен.
от 3D в 2D имаме загуба на информация. Например какъв е ъгъла. 
Също така успоредните линии не са останали успоредни.
Може да се опитаме да направим трансформация от 2D до 3D

директно приложение на линейната алгебра в машинното самообучение - Principal Component Analysis
Всички разказвам отклонения вероятно ще бъдат на изпита.
Какво прави проекция и PCA е част от курса.

На линейните пространства им закачаме дефиниция на скаларно произведение.
Скаларно произведение прави от векторно евклидово пространство.
Всеки път като сложим ограничение върху което правим:
1.Колкото повече изисквания имаме към нещо, толкова повече конкретно знаем какво е и може да изведем повече негови свойства.
При скаларно произведение може да дефинираме разстояние.
Разстоянието е мярка за подобие. Ако имаме 2 обекта на малко разстояние един от друг, значи са подобни. При големи разстояния са много различни. Стои в основата на Supervised learning

Нещата, които можем да описваме с линейна алгебра:
от явления които са независими (не си влияят един за друг), можем да направим линейни комбинации - имаме основа за линейно описание
Например:
y1 = f(3)
y2 = f(5)
Питаме се какво означава тези функии да действат едновременно.
Означаваме едновременното действие с "+"

f(3) + f(5) ако се окаже че = f (3 + 5)
Дейстието върху 2 обекта заедно е сумата върху двете дейсвтия.
нарича се суперпозиция във физиката. Superposition означава наслагване.
Не винаги е изпълнено, но когато е, знаем, че процесите, които протичат, са линейни.
това е едно от изискванията за линейна трансформация
второто изискване = lambda f(А) = f(lambdaА) - закодира изискването една точка от пространството да остава на същото място.
Ако умножа функцията от някакъв вход със някакъв скалар от полето, над което е дефинирано линейното пространство, това трябва да е същото, като че съм умножил входа.
И в това число трябва да има нулев елемент относно събиране или умножение.
Може да е 0 или друг елемент от полето, което играе ролята на 0.
Това за двете изисквания една функция или процес да бъде дефиниран като линеен:

1. f(a) + f(b) = f(a+b)
2.lambda f(A) = f(lambda A)

ако f и g изпълняват условията, то тяхната композиция линейна ли е или не - f(g(x))? 
ако 2 функции са линейни

Кои процеси в природата правят това нещо:
вълните
Вълна е нещо което периодично се променя.
В природата е нещо което се повтаря
принцип на суперпозицията- събирането на двете вълни = общото действие е чисто събиране на двете оргинални - Constructive and destructive interference.
Interference е пример за суперпозицията.
Може да се опитаме от резултата да разделим до оргиналните.
Всеки път като знаем че принципа на суперпозиция действа знаем че нашата система е линейна.
Това отключва много неща.


Процес за решаване на линейни системи.
Метод на Гаус-Джордан за решаване на линейни системи - целта е да се получи единичната матрица
Елементарни операции - разместване на редове, умножаване на редове, събиране на редове
Целта е да се получи единичната матрица
[ 1 0 0 | 3 ]
[ 0 1 0 | 4 ]
[ 0 0 1 | -2]
Трансформациите се композират.
np.linalg.solve - за решаване системи уравнения
Има шанс да няма решение за системата (когато трите прави не се пресичат в една точка - няма решение).
Когато правите се припокриват, решенията са целите прави.
Неопределени и преопределени системи - когато имаме повече неизвестни отколкото уравнения и по-малко.


Решения на задачите:
====================================================================
1.1
gca = get current axes
това което приема quiver не е начало и край, а начало и дължина
разлика от вектори се смята по компоненти.

1.2
Всеки вектор се представя като линейна комбинация на базисните вектори.
v = lambda1e1 + lambda2e2
Като знаем векторите и базисните вектори, можем да намерим коефициентите.

[v1] = lambda1 [e11] + lambda2 [e21]
[v2] =         [e12]           [e22]

умножаване на вектор с число е като умножим всеки един от елементите му.

|v1 = lambda1 e11 + lambda2 e21
|v2 = lambda1 e12 + lambda2 e22

Създаваме матрицата:
!!! Трябва да разположим базисните вектори по колоните. Матричното произведение работи ред по стълб.

[e11 e21] * [lambda1] = [v1]
[e12 e22]   [lambda2]   [v2]

направете numpy масив и направете редовете стълбове.

координатите на един вектор не са негова характеристика. Те са характеристика на координатната система, в която го поставяме.
Неговите характеристики са дължина и посока
Координатите са характеристика на гледната точка.

1.3
скаларното произведение на два ортогоноални вектора е 0 (a.b = 0)(заради cos 90 градуса е 0)
Дължините им могат да се намерят по питагоровата теорема.
Може да се вземат ортогонални вектори с различна дължина.
дължина на вектора може да се получи и с неговата норма = норма е генерализация на дължина
np.linalg.norm()

имаме различни норми
Какво е норма от ред 2 - корен втори - дава питагоровата теорема - евклидовото разстояние
първа норма дава сума от дължините
нулевата норма е броя ненулеви компоненти на вектора - защото нещо на нулева степен е 0, но може да имаме и нулеви коеф.
норма безкрайност - максималния елемент

Векторът остава един и същ.
Променяме начина, по който гледаме на пространството.


2.
%timeit  - с 1% и пишем код който да се изпълни, с 2%% се изпълнява цялата клетка.
np.random


Матрица на ротация има 4 елемента.

Хомография, homography panorama
Тримерен ъгъл на завъртане, което има 3 измерение - ъгли на Ойлер
Image processing using python
Трябва да знаем някакво инфо за оргиналния обект
неравенство на коши
Има специални базиси, които се запазват. Няма ги винаги, има ги само в квадратните матрици.
Експонента от матрица, синус от матрица
	
4.
cat_image.shape
връща (475, 632, 3)
3 означава 3 канала
Черно-бяло изображение (Average grayscale image) и гама проекция.
При черно-белите има само 1 канал.
The ravel() function in NumPy is used to flatten multi-dimensional arrays into a one-dimensional array. It returns a flattened array by unraveling or flattening the array elements in row-major order (C-style order).

хистограма за всеки канал
Да използваме matplotlib.pyplot.subplots

enumerate - Return an enumerate object.

From https://stackoverflow.com/questions/20174468/how-to-create-subplots-of-pictures-made-with-the-hist-function-in-matplotlib-p
import matplotlib.pyplot as plt
import numpy as np

data=np.random.random((4,10))
xaxes = ['x1','x2','x3','x4']
yaxes = ['y1','y2','y3','y4']
titles = ['t1','t2','t3','t4'] 

f,a = plt.subplots(2,2)
a = a.ravel()
for idx,ax in enumerate(a):
    ax.hist(data[idx])
    ax.set_title(titles[idx])
    ax.set_xlabel(xaxes[idx])
    ax.set_ylabel(yaxes[idx])
plt.tight_layout()


Solution:
# Write your code here
data=[cat_image_r_normalized, cat_image_g_normalized, cat_image_b_normalized]
xaxes = ['x1','x2','x3']
yaxes = ['y1','y2','y3']
titles = ['red','green','blue'] 

f,a = plt.subplots(1,3)
a = a.ravel()
for idx,ax in enumerate(a):
    ax.hist(data[idx].ravel(), bins = 256, alpha = 0.5, label = titles[idx])
#    ax.hist(data[idx])
#    ax.set_title(titles[idx])
#    ax.set_xlabel(xaxes[idx])
#    ax.set_ylabel(yaxes[idx])
plt.xlim(0, 1)
plt.title("Image histograms comparison")
plt.legend()
plt.tight_layout()